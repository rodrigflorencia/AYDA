
#include "Grafo.hpp"

/**
 * @brief Implementación de un grafo genérico utilizando lista de adyacencias.
 * @tparam V Tipo de dato para los vértices.
 */
template <class V> Grafo<V>::Grafo() {
  this->nV = 0;
  this->noDirigido = false;
}

/**
 * @brief Destructor.
 *
 */
template <class V> Grafo<V>::~Grafo() {}

/**
 * @brief Constructor con parámetro para definir si el grafo es dirigido o no.
 * @param noDirigido Indica si el grafo es no dirigido.
 */
template <class V> Grafo<V>::Grafo(bool noDirigido) {
  this->nV = 0;
  this->noDirigido = noDirigido;
}

template <class V> bool Grafo<V>::_existeVertice(const V &v) const {
  bool encontro = false;
  typename vector<V>::const_iterator it = this->vertices.begin();
  while (it != this->vertices.end() && !encontro) {
    if (*it == v)
      encontro = true;
    it++;
  }
  return encontro;
}

/**
 * @brief Agrega un vértice al grafo.
 * @param v Vértice a agregar.
 * @return true si el vértice se agrega, false si ya existía.
 */
template <class V> bool Grafo<V>::addVertice(const V &v) {
  if (!_existeVertice(v)) {
    this->vertices.push_back(v);
    this->grafo.push_back(list<int>());
    this->nV++;
    return true;
  }
  return false;
}

/**
 * @brief Agrega un arco entre dos vértices. Complejidad orden logaritmico.
 * @param u Vértice origen.
 * @param v Vértice destino.
 * @return true si la arista se agrega correctamente.
 */
template <class V> bool Grafo<V>::addArco(const V &u, const V &v) {
  if (hayArco(u, v))
    return false;
  if (!this->_existeVertice(u))
    this->addVertice(u);

  if (!this->_existeVertice(v))
    this->addVertice(v);

  int iU = this->_getIndice(u);
  int iV = this->_getIndice(v);

  if (iU < 0 || iV < 0)
    return false;
  this->grafo[iU].push_back(iV);

  if (this->noDirigido)
    this->grafo[iV].push_back(iU);
  return true;
}

/**
 * @brief Verifica si existe un arco entre dos vértices.
 * @param u Vértice origen.
 * @param v Vértice destino.
 * @return true si existe, false si no.
 */
template <class V> bool Grafo<V>::hayArco(const V &u, const V &v) const {
  if (!this->_existeVertice(u) || !this->_existeVertice(v)))
    return false;
  int i = 0;
  bool hayArco = false;
  while (i < this->nV && !hayArco) {
    typename list<int>::const_iterator it = this->grafo[i].begin();
    while (it != this->grafo[i].end() && !hayArco) {
      if (this->vertices[*it] == v)
        hayArco = true;
      it++;
    }
    i++;
  }
  return hayArco;
}

/**
 * @brief Devuelve un conjunto con los adyacentes de un vértice. Costo
 * logaritmico O(log n).
 * @param v Vértice de referencia.
 * @return Conjunto con los vértices adyacentes.
 */
template <class V> set<V> Grafo<V>::getAdyacentes(const V &v) const {
    int i = this->_getIndice(v);
    if (i < 0)
      return set<V>();
    set<V> adyacentes;
    for (V v: this->grafo[i])
        adyacentes.insert(this->vertices[*v]);
  if (grafoMapa.find(v) == grafoMapa.end()) // O(log n)
    return set<V>();                        // O(1)
  return grafoMapa.find(v)->second;         // O(log n)
}

/**
 * @brief Devuelve un conjunto con los vértices del grafo. Costo lineal O(n)
 * @param u Vértice de referencia.
 * @return Conjunto con los vértices del grafo.
 */
template <class V> set<V> Grafo<V>::getVertices() const {
  set<V> v;
  int i = 0;
  for (typename map<V, set<V>>::const_iterator it = this->grafoMapa.begin();
       it != this->grafoMapa.end(); it++)
    v.insert(it->first);
  return v;
}

/**
 * @brief Devuelve la cantidad de vértices actuales del grafo. O(1)
 * @return Número de vértices.
 */
template <class V> int Grafo<V>::nVertices() const {
  return grafoMapa.size(); // O(1)
}

// ==============================================
// Instanciaciones explícitas de la plantilla
// ==============================================
template class Grafo<int>;
template class Grafo<char>;
template class Grafo<double>;
template class Grafo<string>;
